	0	DSP		4			;	var 0 = limit, var 1 = count, var 2 = i, var 3 = ch		
	2	LDC		2000
	4	STL_0				;	limit = 2000
	5	LDA_1
	6	LDL_0				; 	could just LDC 2000 instead of LDA  & LDV, but this is probs better practice
	7	ANEW				;	int[] count = new int[limit]
	8	STO
	9	LDC_0
	10	STL_2				;	int i = 0
	11	LDL_2				;	while (i<limit)		{B}
	12	LDL_0
	13	CLT					;	i<limit?	(pushes 1 or 0)					
	14	BZE		49			;	if i>=limit, skip past loop.	{A}	
	16	LDL_1
	17	LDL_2
	18	LDXA				;	count[i]
	19	LDC_0
	20	STO					;	count[i] = 0		
	21	LDL_2
	22	LDC_1
	23	ADD					
	24	STL_2				;	i++			{INC}
	25	BRN		19			;	{B}
	26	LDA_3				;	{A}
	27	INPI				;	 read(ch)
	28	LDL_3				;	 while ((ch > 0) && (ch < limit))	{D}
	29	LDC_0
	30	CGT					;	ch > 0?	(pushes 1 or 0)	
	31	LDL_3
	32	LDL_0
	33	CLT					;	ch < limit?	(pushes 1 or 0)
	34	AND
	35	BZE		96			;	(ch > 0) && (ch < limit) {C}
	37	LDL_1
	38	LDL_3				
	39	LDXA				;	address of count[ch]
	40	LDL_1
	41	LDL_3
	42	LDXA
	43	LDV
	44	CAP
	45	LDC_1
	46	ADD
	47	STO					;	count[toUpperCase(ch)]++	{INC}
	48	LDA_3
	49	PRNS	"Next number (<= 0 stops) "
	51	INPI				;	read("Next number (<= 0 stops) ", ch)
	52	BRN		54			;	{D}				
	54	LDC_0				;	{C}
	55	STL_2				;	i = 0
	56	LDL_2				;	while (i < limit)	{G}
	57	LDL_0
	58	CLT					;	i < limit?	(pushes 1 or 0)
	59	BZE		150			;	Branch if i >= limit {E}			
	61	LDL_1
	62	LDL_2
	63	LDXA				;	address of count[i]			
	64	LDV					;	value of count[i]	(dereferencing)
	65	LDC_0
	66	CGT					;	count[i] > 0?   (pushes 1 if count[i] > 0 and branches if count[i] <= 0) 
	67	BZE		139			;	if(count[i] > 0) {F}	(branches to i = i+1)
	69	LDL_1
	70	LDL_2
	71	LDXA				;	address of count[i]
	72	LDV					;	value of count[i]
	73	LDL_2				;	i
	74	PRNI				;	print i
	75	PRNS	" "			; 	print " "
	77	PRNI				;	print count[i]
	78	PRNL				;	write(i, count[i], "\n")		
	79	LDL_2				;	{F}
	80	LDC_1
	81	ADD					
	82	STL_2					;	i = i + 1
	83	BRN		101			;	{G}
	85	HALT				;	{E}	